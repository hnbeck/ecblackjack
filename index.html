<!--- Java script and HTML implementation fo the GUI ----------------------->
<!---- Autor: Hans N. Beck  (c) -------------------------------------------->


<!DOCTYPE html >
<html>
<head>
	<meta charset="UTF-8" />
	 <link rel="stylesheet" href="/web/bjstyles.css">

	<script src="/web/jquery-1.11.3.min.js"  type="text/javascript"></script>
	<script src="/web/tau-prolog.js" type="text/javascript"></script>
	<script src="/web/pengines.js" type="text/javascript"></script>
	<script src="/web/p5.min.js" type="text/javascript"></script>

	<script type="text/javascript">

		// the Prolog engines
		var pengine; 
		var session = pl.create(1000);

		// globals for Prolog communication
		var resList;
		var result; 

		// the objects, which are costumes
		var lights; 
		var aDesk; 
		var gameCanvas; 
		//var deckCostume; 
		//var bankCostume; 
		var costumes; 
		var aCardFrame; 
		
		// animation globals
		var turnCounter = 0; 

		// useful constants
		const cWidth = 0; 
		const cHeight = 1; 
		const cMargin = 2; 
		const cX = 3;
		const cY = 4; 
		const cMidMargin = 3; 
		const canvasW = 800; 
		const canvasH = 350; 


		// geometric functions
		// calculate a card frame relative to desk frame
		function cardFrame(W,H, deskFrame) {
			var frame = [1, 2, 4, 5, 6];
			frame[cWidth] = W/8; // width
			frame[cHeight] = frame[cWidth] * 1.5; // height
			frame[cMargin] = 5; // margin
			frame[cX] = deskFrame[cMargin] + frame[cMargin];
  			frame[cY] =	deskFrame[cMargin] + frame[cMargin]; 
  				
			return frame; 
		}
		// calculate a desk frame relative to window size
		function deskFrame(W,H) {
			var frame = [1, 2, 4, 5];
			frame[cWidth] = W; // width
			frame[cHeight] = H; // height
			frame[cMargin] = floor(W / 800*16); // margin
			frame[cMidMargin] = frame[cMargin]/2;  // position mid of border
			return frame; 
		}
	
		// Grafikobjekte
		class Lamp {
			constructor(x, y, c, frame) {
				this.color = c; 
				this.x = x; 
				this.y = y; 
				this.diameter = frame[cMargin]; 
				this.lumPhase = 0; 
				this.lichtprofil = new Array(51);

				this.lichtprofil[25] = 50; 
				for (var i = 1; i < 26; i++) {
					this.lichtprofil[25-i] = 50 - (i);
					this.lichtprofil[25+i] = 50 - (i);
				}
			};
			
			luminate(){
				var value = this.fadeLuminance();

				var hVal = hue(this.color);
				var sVal = saturation(this.color);
				this.color = color(hVal, sVal, value);
			};

			fadeLuminance() {
				var value = 25; 

				this.lumPhase += 1; 
				if ((this.lumPhase  >= 0) && (this.lumPhase < this.lichtprofil.length)) {
					value = this.lichtprofil[this.lumPhase];
				} else {
					this.lumPhase = 0; 
				}
				return value; 
			};

			draw() {
				noStroke(); 
				fill(this.color);
				circle(this.x,this.y,this.diameter);
			};
		}

		class Desk {
			constructor(frame) {
				var lampDia = frame[cMargin];
				colorMode(HSL, 360,100,100,1); 

  				let borderCol = color(35,79, 23);
  				let deskCol = color(135,50,21);
  
	  			noStroke(); 
	  			fill(borderCol);
	  			rect(0,0,frame[cWidth],frame[cHeight]);
	  			noStroke(); 
	  			fill(deskCol);
	  			rect(	lampDia,
	  					lampDia,
	  					frame[cWidth]-lampDia-lampDia,
	  					frame[cHeight]-lampDia-lampDia
	  				);
			}
		}

		class LampLine {
			constructor(frame) {
				var deskWidth = frame[cWidth];
				var deskHeight = frame[cHeight];
				var lampDia = frame[cMargin]; // lamps diameter is same as border thickness
				var firstLampX = frame[cMidMargin]; 
				var firstLampY = firstLampX; // Border has in every direction the same thickness
				var lastPosX; 
				var lastPosY; 

				this.lamps = [];

				colorMode(HSL, 360,100,100,1); 
				let col = color(60, 100, 25);

				// try alternative expressen: generate coodinates right down and mirror them
				for (var ix = firstLampX;  ix <= deskWidth; ix += lampDia)
				{
					this.lamps.push(new Lamp(ix, firstLampY, col, frame));
					lastPosX = ix; 
				}
				for (var iy = firstLampY-lampDia; iy <= deskHeight - lampDia; iy += lampDia)
				{
					this.lamps.push(new Lamp(lastPosX, iy, col, frame));
					lastPosY = iy; 
				}
				for (ix = lastPosX; ix >= firstLampX;  ix -= lampDia)
				{
					this.lamps.push(new Lamp(ix, firstLampY+(deskHeight-lampDia), col, frame));
				}
				for (iy = lastPosY; iy >= firstLampY-lampDia;  iy -= lampDia)
				{
					this.lamps.push(new Lamp(firstLampX, iy, col, frame));
					
				}
			}

			draw() {
  				
	  			for (var i = 0; i< this.lamps.length; i++)
	  			{
	  				this.lamps[i].luminate();
	  				this.lamps[i].draw();
	  			}
			}
		}

		class Costume {
			constructor(cardName, cardFrame, playerNo) {
				this.cardFrame = new Array(5);
				this.cardFrame[0] = cardFrame[0];
				this.cardFrame[1] = cardFrame[1];
				this.cardFrame[2] = cardFrame[2];
				this.cardFrame[3] = cardFrame[3];
				this.cardFrame[4] = cardFrame[4];
				this.img = loadImage('/graphics/'+cardName+'.png');
				//console.log('costume name is: ' + cardName);
				//console.log('costume cX ' + this.cardFrame[cX] + ' cy ' + this.cardFrame[cY]);
				this.owner = playerNo;  
				this.screentext = ""; 

				// Geometrieinformation für mögliche Orte
				this.nextPlace =  [this.cardFrame[cMargin] + this.cardFrame[cWidth],
									this.cardFrame[cMargin] + this.cardFrame[cHeight]];

			}
			draw() {
				image(this.img, 
  					this.cardFrame[cX], 
  					this.cardFrame[cY], 
  					this.cardFrame[cWidth],
  					this.cardFrame[cHeight]
  				);
  				textSize(20);
  				textAlign(CENTER, CENTER);
  				var X = this.cardFrame[cX] ;
  				var Y = this.cardFrame[cY] ;
  				text(this.screentext, X, Y, this.cardFrame[cWidth] , this.cardFrame[cHeight]);
			}
			position(cardNo){
				this.cardFrame[cX] = this.places[this.owner][0] + cardNo*this.nextPlace[0];
				this.cardFrame[cY] = this.places[this.owner][1];
			}

			touch(aX, aY ){
				var retVal = false; 

				if (aX > this.cardFrame[cX]) 
					if (aX < this.cardFrame[cX]+this.cardFrame[cWidth])
						if (aY > this.cardFrame[cY])
							if (aY < this.cardFrame[cY]+this.cardFrame[cHeight])
								retVal = true; 


				return retVal; 
			}
			mytext(Text) {
				this.screentext = Text; 
				//console.log('touched');
				//console.log(this.screentext);
			}
			geometry(aPlaceDef) {

				this.places = aPlaceDef;
				for (var n = 0; n <3 ; n++)
				{
					this.places[n][0] = this.cardFrame[cX] + aPlaceDef[n][0] *this.nextPlace[0];
					this.places[n][1] = this.cardFrame[cY] + aPlaceDef[n][1] *this.nextPlace[1];
				}
			}
		}

		//////////////// Processing code -> graphics ////////////////////

		// setup the geometric things
		function setup() {
			
			costumes = []; 

			// the main desk
			var aDeskFrame = deskFrame(canvasW, canvasH);
			// a Frame for the deck of costumes. Its also a prototype for every cardframe
			var aDeckFrame = cardFrame(canvasW, canvasH, aDeskFrame); 
			// cardframe for one drawn card
			aCardFrame = cardFrame(canvasW, canvasH, aDeskFrame); 
  		
  			gameCanvas = createCanvas(canvasW, canvasH);
  			gameCanvas.parent('p1Container');
  			aDesk = new Desk(aDeskFrame);
  			
  			lights = new LampLine(aDeskFrame); 

  			// that  have to be at the end ! the JS objects shall exist if init prolog
  			frameRate(20);
			init_Prolog();
		}

		// processing main draw function
		function draw() {
			lights.draw();
			// query the active player, result is in Tauhtml
			session.query('activePlayerNo.');
			session.answer(printAnswer);
			
			var text = $("#Tauhtml").text();
			var index; 

			// determine for which costume the text is indented, Bank is costume 1, player 0
			if (text == 'Bank')	{
				index = 1; 
			} else	{
				index = 0; 
			}	
				
  			for (var i = 0; i < costumes.length; i++)
  			{
  				costumes[i].mytext('');
  				if (i == index ) 
  					costumes[i].mytext(text);

  				costumes[i].draw();
  			}
  			
		}
 		
 		function mouseClicked(){

 			if (costumes[1].touch(mouseX, mouseY))
 			{
 				session.query('playAction.');
 				session.answer(printAnswer);
 			}
 		}

 		// interface Prolog to Graphics
 		function newCostume(name, playerNo, cardNo, aPlaceDef ) {
 			console.log("new Costume " + name);

			//console.log('New Costume called with player ' + playerNo + 'turn ' + turnCounter);
			currentCostume = new Costume(name, aCardFrame, playerNo);
			currentCostume.geometry(aPlaceDef);
			currentCostume.position(cardNo); 
			costumes.push(currentCostume);
			turnCounter += 1; 
 			
 		}

 	
 		//////////////// Prolog Code //////////////////

 		// setup Prolog system
		function init_Prolog() {
			$.get("/web/webProlog.pl", function(data) {
				session.consult(data);
		 	});

			// Tau is ready, now pengine
			pengine = new Pengine({
				oncreate: handleCreate, 
				onsuccess: handleOutput,
				destroy: false
			}); 	

			
			// call the init of the game
			//pengine.ask('playGame(PA2, PP2, Msg)');
			console.log('Prolog Init done');
		}
		
		// here are the Pengine handle functions
		function handleCreate() {
			// init tau prolog
			session.query("init.");
			session.answer(printAnswer);
			$("#Tauhtml").text('');
			// call the init of the game
			pengine.ask('playGame(P1, P2, Flag, Msg)');
		}
		// Pengine handle function for reveiving SWI Prolog answer
		function handleOutput(){
			// store the answer into global variable for later analysis
			// in future should be more intelligent. P1 P2 must not be there always
		
			resList = []; 
			for (x in this.data[0])
			{
				// properties must be lowercase later for Tau Prolog
				this.data[0][x.toLowerCase()] = this.data[0][x];
				this.data[0][x].delete;
				resList.push(x.toLowerCase());
			}
			result = this.data[0];
			console.log(result);
			
			session.query("takeResult(["+ resList.toString() + "], result, Term).");
			session.answer(printAnswer);
			session.query("gameContinue.");
			session.answer(printAnswer);
		}

		/////// Tau Prolog ///////

		// Callback needed for triggering and displaying answers of Tau prolog querys
		var printAnswer = function(answer){
			// Debug code
			//$("#Tauout").append(pl.format_answer(answer));
			//$("#Tauout").append("<br>");
			//console.log('Tau answer:' + answer);
		}

		function sendPengine() {
			var query = $("#Tauhtml").text();
			console.log("Query will be: " + query);
			pengine.ask(query);
		}

	</script>


	<title> Demo game Black Jack </title>
	
</head>
<body>
	
	<div id="playarea">

		<h1>Demo game Black Jack</h1>
		</p>
		<h3>This simple game is intended as template for projects using SWI Prolog, its Pengines library and Tau-Prolog.</h3>
		
		<p>
		<div id='p1Container'></div>	
		</p>
		<div id="pout"></div>
		<hr>
	</div>
	
	<!-- standard this section is invisible - only for debug -->

	<div id="testblock"> 
		<h4> Test / Debug area </h4>
		<p> The test below queries for a hard coded predicate .</p>

		 Output for Tau Prolog queries. Output is done via callback of the pl.answer function of Tau Prolog.
		 </p>
		 <div id="Tauout"></div>
		 </p>
		 <div id="Tauhtml">Tau terms</div>

	</div>
</p>
	
</body>
</html>